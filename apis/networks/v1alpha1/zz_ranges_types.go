/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type RangesObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type RangesParameters struct {

	// +kubebuilder:validation:Optional
	AllocMode *string `json:"allocMode,omitempty" tf:"alloc_mode,omitempty"`

	// +kubebuilder:validation:Optional
	Annotation *string `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	From *string `json:"from" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	NameAlias *string `json:"nameAlias,omitempty" tf:"name_alias,omitempty"`

	// +kubebuilder:validation:Optional
	Role *string `json:"role,omitempty" tf:"role,omitempty"`

	// +kubebuilder:validation:Required
	To *string `json:"to" tf:"to,omitempty"`

	// +crossplane:generate:reference:type=VlanPool
	// +kubebuilder:validation:Optional
	VlanPoolDn *string `json:"vlanPoolDn,omitempty" tf:"vlan_pool_dn,omitempty"`

	// +kubebuilder:validation:Optional
	VlanPoolDnRef *v1.Reference `json:"vlanPoolDnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	VlanPoolDnSelector *v1.Selector `json:"vlanPoolDnSelector,omitempty" tf:"-"`
}

// RangesSpec defines the desired state of Ranges
type RangesSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RangesParameters `json:"forProvider"`
}

// RangesStatus defines the observed state of Ranges.
type RangesStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RangesObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Ranges is the Schema for the Rangess API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,acijet}
type Ranges struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RangesSpec   `json:"spec"`
	Status            RangesStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RangesList contains a list of Rangess
type RangesList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Ranges `json:"items"`
}

// Repository type metadata.
var (
	Ranges_Kind             = "Ranges"
	Ranges_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Ranges_Kind}.String()
	Ranges_KindAPIVersion   = Ranges_Kind + "." + CRDGroupVersion.String()
	Ranges_GroupVersionKind = CRDGroupVersion.WithKind(Ranges_Kind)
)

func init() {
	SchemeBuilder.Register(&Ranges{}, &RangesList{})
}
